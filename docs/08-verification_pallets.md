---
title: Verification Pallets
---

Zkverify provide a set of verifier pallets that expose `submitProof` extrinsic call
to verify the given proofs and store the proof statement.

Every time that a valid proof is verified the `Zkverify` emit an **event** that identify the
submitted statement and the `id` that can be used to check proof availability on the
destination chain (i.e. Ethereum). All verified statements are uniquely identified by the
hash computed as follows

```text
hash := Keccak256('<verifier-id>-'<public-input>)
```

where:

* `verifier-id` is a unique identifier string for what statement we should prove
* `public-input` are the public input bytes of the proved statement

## Fflonk Verifier

This verifier check if the given proof is a Polygon-CDK Fork-Id 6 valid proof. The input proof format
is 800 bytes array where the last 32 bytes are the public inputs: the pallet use
[`fflonk_verifier` crate](https://github.com/HorizenLabs/fflonk_verifier/tree/v0.3.0) to deserialize
the proof and public inputs and then verify them. If we put error handling aside we can sketch the pallet duty
with the following code snipped

```rust
let proof = Proof::try_from(&proof_data).unwrap();
let pubs = pubs_data.into();

proof.verify(pubs).unwrap()
```

If the proof is correct a `Poe::NewElement(statement, attestation_id)` event is emitted where `statement`
is computed by use `fflonk` as `verifier-id`.

This call can fail both if be not possible deserialize the proof (`InvalidProofData`) or proof don't 
verify (`VerifyError`)

## Zksync Verifier

This verifier can be used to verify ZkSync-Era proofs; these proofs are generated by Boojum prover that's a
STARK-based proof system. ZkSync-Era roolups generate these proofs and you can verify them on ZkVerify instead of
post them directly on Ethereum. The input proof format is 1440 bytes array where the last 32 bytes are the
public inputs: the pallet use [`zksync-era-verifier` crate](https://github.com/HorizenLabs/zksync-era-verifier/tree/v0.1.0)
to deserialize the proof and public inputs and then verify them. If we put error handling aside we can
summarize the pallet duty with the following code snipped

```rust
use zksync_era_verifier::{default_eth_vk, deserialize_eth_proof, verify, ZkSyncEthProof};

let mut eth_proof: ZkSyncEthProof =
    deserialize_eth_proof(&proof_data).unwrap();
eth_proof.inputs = &proof_data.to_vec();
let vk = default_eth_vk();
assert!(verify(&vk, &eth_proof).unwrap());
```

If the proof is correct a `Poe::NewElement(statement, attestation_id)` event is emitted where `statement`
is computed by use `zksync` as `verifier-id`.

This call can fail both if be not possible deserialize the proof or public inputs (`InvalidProofData`, 
`InvalidInput`) or proof don't verify (`VerifyError`).
